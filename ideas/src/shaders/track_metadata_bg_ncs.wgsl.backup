// NCS-Inspired Waveform Visualizer - Clean & Reactive
// Horizontal waveform bars with smooth FFT response

struct Uniforms {
    time: f32,
    audio_bass: f32,
    audio_mid: f32,
    audio_high: f32,
    resolution: vec2<f32>,
    _pad0: vec2<f32>,
}

@group(0) @binding(0)
var<uniform> uniforms: Uniforms;

struct VSOut {
    @builtin(position) pos: vec4<f32>,
    @location(0) uv: vec2<f32>,
};

// Hash for pseudo-random
fn hash(n: f32) -> f32 {
    return fract(sin(n) * 43758.5453123);
}

// Smooth waveform bar (horizontal)
fn waveBar(uv: vec2<f32>, y_pos: f32, width: f32, thickness: f32) -> f32 {
    let d = abs(uv.y - y_pos) - thickness * 0.5;
    return smoothstep(0.005, 0.0, d) * smoothstep(-width, -width + 0.02, uv.x) * smoothstep(width, width - 0.02, uv.x);
}

@vertex
fn vs_main(@builtin(vertex_index) vertex_index: u32) -> VSOut {
    var out: VSOut;
    let x = f32((vertex_index & 1u) << 2u);
    let y = f32((vertex_index & 2u) << 1u);
    out.pos = vec4<f32>(x - 1.0, 1.0 - y, 0.0, 1.0);
    out.uv = vec2<f32>(x * 0.5, y * 0.5);
    return out;
}

@fragment
fn fs_main(in: VSOut) -> @location(0) vec4<f32> {
    let fragCoord = in.uv * uniforms.resolution;
    var uv = (fragCoord - uniforms.resolution * 0.5) / uniforms.resolution.y;
    
    let num_bars = 10.0;  // Fewer, smaller bars
    let bar_spacing = 0.1;
    
    var col = vec3<f32>(0.0);
    let audio_avg = (uniforms.audio_bass + uniforms.audio_mid + uniforms.audio_high) / 3.0;
    
    // Draw horizontal waveform bars (center-out pattern)
    for (var i = 0.0; i < num_bars; i += 1.0) {
        let norm_i = (i / num_bars) - 0.5;  // -0.5 to 0.5
        let y = norm_i * 1.2;  // Vertical position (reduced spread)
        
        // Map to frequency bands
        let abs_norm = abs(norm_i);
        var energy: f32;
        if (abs_norm < 0.2) {
            energy = uniforms.audio_bass;  // Center = bass
        } else if (abs_norm < 0.4) {
            energy = uniforms.audio_mid;   // Middle = mids
        } else {
            energy = uniforms.audio_high;  // Edges = highs
        }
        
        // Animated width with wave motion
        let wave = sin(uniforms.time * 3.0 + i * 0.5) * 0.1 + 0.9;
        let pulse = sin(uniforms.time * 5.0 + i * 0.3) * 0.05 + 0.95;
        var width = energy * 0.5 * wave * pulse;  // Reduced from 0.7 to 0.5
        width = max(width, 0.03);  // Smaller minimum
        
        let thickness = 0.01 * (1.0 + energy * 0.3);  // Thinner bars
        let bar_val = waveBar(uv, y, width, thickness);
        
        // Color gradient: bass=purple/pink, mid=blue/cyan, high=green/yellow
        var bar_color: vec3<f32>;
        if (abs_norm < 0.2) {
            bar_color = mix(vec3<f32>(0.8, 0.2, 1.0), vec3<f32>(1.0, 0.3, 0.8), sin(uniforms.time * 2.0 + i) * 0.5 + 0.5);
        } else if (abs_norm < 0.4) {
            bar_color = mix(vec3<f32>(0.2, 0.6, 1.0), vec3<f32>(0.3, 0.9, 1.0), sin(uniforms.time * 2.0 + i + 1.0) * 0.5 + 0.5);
        } else {
            bar_color = mix(vec3<f32>(0.3, 1.0, 0.5), vec3<f32>(0.9, 1.0, 0.3), sin(uniforms.time * 2.0 + i + 2.0) * 0.5 + 0.5);
        }
        
        // Add glow (reduced for smaller bars)
        let glow = bar_val * 1.5 * (1.0 + audio_avg * 0.3);
        col += bar_color * bar_val * 1.0;
        col += bar_color * glow * 0.4;
    }
    
    // Animated gradient background
    let bg_gradient = smoothstep(-0.8, 0.8, uv.y) * 0.15;
    col += vec3<f32>(0.05, 0.08, 0.12) * bg_gradient;
    
    // Center pulse effect
    let center_dist = length(uv);
    let pulse = sin(uniforms.time * 4.0) * 0.5 + 0.5;
    let center_glow = exp(-center_dist * 2.0) * 0.1 * audio_avg * pulse;
    col += vec3<f32>(0.5, 0.7, 1.0) * center_glow;
    
    // Subtle vignette
    let vignette = 1.0 - length(uv * 0.4);
    col *= vignette;
    
    return vec4<f32>(col, 1.0);
}

