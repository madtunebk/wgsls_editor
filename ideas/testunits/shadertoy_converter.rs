// Shadertoy to WGSL Converter Test Unit
// Converts GLSL shaders from Shadertoy to WGSL format for TempRS

use std::fs;
use std::env;

fn convert_shadertoy_to_wgsl(glsl_code: &str) -> String {
    let mut wgsl = glsl_code.to_string();
    
    // 1. Replace void mainImage(out vec4 fragColor, in vec2 fragCoord) with fs_main
    wgsl = wgsl.replace(
        "void mainImage( out vec4 fragColor, in vec2 fragCoord )",
        "@fragment\nfn fs_main(in: VSOut) -> @location(0) vec4<f32>"
    );
    wgsl = wgsl.replace(
        "void mainImage(out vec4 fragColor, in vec2 fragCoord)",
        "@fragment\nfn fs_main(in: VSOut) -> @location(0) vec4<f32>"
    );
    
    // 2. Replace fragCoord with in.uv * uniforms.resolution
    wgsl = wgsl.replace("fragCoord", "in.uv * uniforms.resolution");
    
    // 3. Replace iTime with uniforms.time
    wgsl = wgsl.replace("iTime", "uniforms.time");
    
    // 4. Replace iResolution with uniforms.resolution (vec3 -> vec2)
    wgsl = wgsl.replace("iResolution.xy", "uniforms.resolution");
    wgsl = wgsl.replace("iResolution.x", "uniforms.resolution.x");
    wgsl = wgsl.replace("iResolution.y", "uniforms.resolution.y");
    
    // 5. Replace fragColor with return statement
    wgsl = wgsl.replace("fragColor =", "return");
    wgsl = wgsl.replace("fragColor=", "return");
    
    // 6. GLSL -> WGSL type conversions
    // First convert types, then we'll fix variable declarations
    wgsl = wgsl.replace("vec2", "vec2<f32>");
    wgsl = wgsl.replace("vec3", "vec3<f32>");
    wgsl = wgsl.replace("vec4", "vec4<f32>");
    wgsl = wgsl.replace("mat2", "mat2x2<f32>");
    wgsl = wgsl.replace("mat3", "mat3x3<f32>");
    wgsl = wgsl.replace("mat4", "mat4x4<f32>");
    wgsl = wgsl.replace("float", "f32");
    
    // 7. Fix variable declarations: "vec2<f32> name =" -> "let name: vec2<f32> ="
    // This is a simple regex-like replacement for common patterns
    wgsl = wgsl.replace("vec2<f32> ", "let ");
    wgsl = wgsl.replace("vec3<f32> ", "let ");
    wgsl = wgsl.replace("vec4<f32> ", "let ");
    wgsl = wgsl.replace("f32 ", "let ");
    
    // 8. Fix double type declarations (vec4<f32><f32> -> vec4<f32>)
    wgsl = wgsl.replace("<f32><f32>", "<f32>");
    wgsl = wgsl.replace("<f32><f32>", "<f32>"); // Run twice for triple cases
    
    // 9. Function syntax - careful with "let" conflicts
    // Skip this for now as it conflicts with variable declarations
    
    // 10. Fix double return types (-> f32 -> f32 becomes -> f32)
    wgsl = wgsl.replace("-> f32 -> f32", "-> f32");
    
    // 11. GLSL functions -> WGSL equivalents
    wgsl = wgsl.replace("fract(", "fract(");  // Same
    wgsl = wgsl.replace("mix(", "mix(");      // Same
    wgsl = wgsl.replace("mod(", "fmod(");     // Different!
    wgsl = wgsl.replace("atan(", "atan2(");   // Check usage
    
    // 11. Texture sampling (if any)
    wgsl = wgsl.replace("texture(", "textureSample(");
    
    // 12. Swizzling stays the same (.xy, .xyz, .xyx, etc.)
    
    // 13. Add required structs at the beginning
    let header = r#"// Converted from Shadertoy GLSL to WGSL
// Auto-generated by shadertoy_converter.rs

struct Uniforms {
    time: f32,
    audio_bass: f32,
    audio_mid: f32,
    audio_high: f32,
    resolution: vec2<f32>,
    _pad0: vec2<f32>,
}

@group(0) @binding(0)
var<uniform> uniforms: Uniforms;

struct VSOut {
    @builtin(position) pos: vec4<f32>,
    @location(0) uv: vec2<f32>,
}

@vertex
fn vs_main(@builtin(vertex_index) vertex_index: u32) -> VSOut {
    var out: VSOut;
    let x = f32((vertex_index & 1u) << 1u);
    let y = f32((vertex_index & 2u));
    out.pos = vec4<f32>(x * 2.0 - 1.0, 1.0 - y * 2.0, 0.0, 1.0);
    out.uv = vec2<f32>(x, y);
    return out;
}

"#;
    
    format!("{}\n{}", header, wgsl)
}

fn main() {
    println!("=== Shadertoy to WGSL Converter ===\n");
    
    // Get input file from command line argument
    let args: Vec<String> = env::args().collect();
    
    let glsl_code = if args.len() > 1 {
        // Read from file specified in argument
        let input_path = &args[1];
        println!("Reading shader from: {}", input_path);
        fs::read_to_string(input_path)
            .unwrap_or_else(|e| {
                eprintln!("Error reading file '{}': {}", input_path, e);
                std::process::exit(1);
            })
    } else {
        // Default example shader if no argument
        println!("No input file specified, using example shader");
        println!("Usage: shadertoy_converter <input.glsl> [output.wgsl]\n");
        r#"
void mainImage( out vec4 fragColor, in vec2 fragCoord )
{
    vec2 uv = fragCoord/iResolution.xy;
    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));
    fragColor = vec4(col,1.0);
}
"#.to_string()
    };
    
    println!("Input GLSL:\n{}\n", glsl_code);
    let wgsl = convert_shadertoy_to_wgsl(&glsl_code);
    println!("Output WGSL:\n{}\n", wgsl);
    
    // Determine output path
    let output_path = if args.len() > 2 {
        // Use specified output file
        args[2].clone()
    } else {
        // Default output
        "src/shaders/converted_test.wgsl".to_string()
    };
    
    // Save to file
    fs::write(&output_path, &wgsl).expect("Failed to write WGSL file");
    println!("✓ Saved to {}", output_path);
    
    println!("\n=== Conversion Notes ===");
    println!("✓ Replaced mainImage with fs_main");
    println!("✓ Converted fragCoord to in.uv * uniforms.resolution");
    println!("✓ Replaced iTime with uniforms.time");
    println!("✓ Replaced iResolution with uniforms.resolution");
    println!("✓ Converted GLSL types to WGSL types");
    println!("\n⚠ Manual fixes may be needed:");
    println!("  - Complex function signatures");
    println!("  - Texture sampling");
    println!("  - mod() vs fmod() semantics");
    println!("  - atan() vs atan2() usage");
    println!("  - const declarations");
    println!("  - Arrays and structs");
    
    println!("\n=== How to Use ===");
    println!("shadertoy_converter <input.glsl> [output.wgsl]");
    println!("");
    println!("Examples:");
    println!("  shadertoy_converter shader.glsl");
    println!("  shadertoy_converter shader.glsl my_shader.wgsl");
    println!("  shadertoy_converter ideas/fire.glsl src/shaders/fire.wgsl");
    println!("");
    println!("Steps:");
    println!("1. Copy Shadertoy shader code to a .glsl file");
    println!("2. Run: ./target/release/shadertoy_converter shader.glsl");
    println!("3. Check output file for any manual fixes needed");
    println!("4. Test with shader_test binary");
}
